import os
import numpy as np
from PIL import Image
import tensorflow as tf
from tensorflow import keras

# ---------------------------
# 1. 설정 부분
# ---------------------------
# 저장된 모델 경로 (학습 완료된 모델, 2-class, .h5 형식)
MODEL_PATH = "cnn_model_2class_256.h5"

# 테스트 폴더 경로 (여기에는 탐지할 exe 파일들이 위치)
TEST_FOLDER = r"C:\MalwareDetect\malware_test"

# exe 파일을 변환할 때 사용할 이미지 크기 (256×256으로 변환)
CONVERT_SIZE = 256

# CNN 입력 크기 (224×224, 1채널)
IMG_HEIGHT = 224
IMG_WIDTH = 224
CHANNELS = 1

# 변환된 BMP 파일을 임시로 저장할 폴더 (존재하지 않으면 생성)
TEMP_BMP_FOLDER = r"C:\MalwareDetect\temp_bmp"
os.makedirs(TEMP_BMP_FOLDER, exist_ok=True)

# ---------------------------
# 2. exe 파일을 BMP 이미지로 변환하는 함수
# ---------------------------
def convert_exe_to_bmp(exe_path, output_bmp_path, image_size=CONVERT_SIZE):
    """
    exe 파일을 읽어, 총 픽셀 수 = image_size * image_size인 1차원 배열로 변환한 후,
    부족하면 0으로 패딩하고, 넘치면 자른 후, 2D 배열(그레이스케일)로 변환하여 BMP 파일로 저장합니다.
    """
    with open(exe_path, "rb") as f:
        data = f.read()
    # 바이트 데이터를 numpy array (uint8)
    arr = np.frombuffer(data, dtype=np.uint8)
    required = image_size * image_size
    if arr.size < required:
        arr = np.pad(arr, (0, required - arr.size), mode='constant', constant_values=0)
    else:
        arr = arr[:required]
    img_array = arr.reshape((image_size, image_size))
    # PIL 이미지 생성 (그레이스케일 "L" 모드)
    img = Image.fromarray(img_array, mode='L')
    img.save(output_bmp_path)
    return output_bmp_path

# ---------------------------
# 3. BMP 파일을 전처리하여 모델 입력으로 변환하는 함수
# ---------------------------
def preprocess_image(image_path):
    """
    BMP 파일을 열어 그레이스케일("L")로 변환, 224x224 크기로 리사이즈 및 표준화 후,
    (1, IMG_HEIGHT, IMG_WIDTH, 1) 형태의 텐서를 반환합니다.
    """
    try:
        img = Image.open(image_path)
    except Exception as e:
        raise ValueError(f"Error opening image {image_path}: {e}")
    
    # 이미지가 그레이스케일이 아니라면 "L" 모드로 변환
    if img.mode != "L":
        img = img.convert("L")
    # 리사이즈 (224x224)
    img = img.resize((IMG_WIDTH, IMG_HEIGHT), Image.ANTIALIAS)
    # NumPy 배열로 변환 (dtype: float32)
    img_array = np.array(img).astype('float32')
    # per-image standardization: (x - mean) / std
    mean = np.mean(img_array)
    std = np.std(img_array)
    img_array = (img_array - mean) / (std if std > 0 else 1)
    # 채널 차원 추가 → (IMG_HEIGHT, IMG_WIDTH, 1)
    img_array = np.expand_dims(img_array, axis=-1)
    # 배치 차원 추가 → (1, IMG_HEIGHT, IMG_WIDTH, 1)
    img_array = np.expand_dims(img_array, axis=0)
    return img_array

# ---------------------------
# 4. 예측 함수
# ---------------------------
def predict_image(image_path, model):
    """
    주어진 BMP 파일 경로를 전처리하여 모델 예측을 수행합니다.
    예측 결과 (클래스, 확률)를 반환합니다.
    """
    processed_image = preprocess_image(image_path)
    predictions = model.predict(processed_image)
    predicted_class = np.argmax(predictions, axis=-1)[0]
    confidence = predictions[0][predicted_class]
    return predicted_class, confidence

# ---------------------------
# 5. 메인 실행 함수 (결과 요약 포함)
# ---------------------------
def main():
    if not os.path.isdir(TEST_FOLDER):
        print("Test folder not found:", TEST_FOLDER)
        return

    # 저장된 모델 로드
    model = keras.models.load_model(MODEL_PATH)
    
    # 예측 클래스에 대한 라벨 매핑: 예시로 {0: "정상", 1: "악성"}
    label_map = {0: "정상", 1: "악성"}

    # 결과 집계를 위한 변수: 각 클래스별 파일 수, 누적 신뢰도, 파일명 목록
    summary = {
        0: {"count": 0, "total_confidence": 0.0, "files": []},
        1: {"count": 0, "total_confidence": 0.0, "files": []}
    }
    total_files = 0

    # TEST_FOLDER 내의 모든 파일에 대해 처리
    for filename in os.listdir(TEST_FOLDER):
        full_path = os.path.join(TEST_FOLDER, filename)
        if os.path.isfile(full_path):
            name, ext = os.path.splitext(filename)
            # exe 파일이면 BMP로 변환 후 예측 수행
            if ext.lower() == ".exe":
                temp_bmp_path = os.path.join(TEMP_BMP_FOLDER, name + ".bmp")
                try:
                    convert_exe_to_bmp(full_path, temp_bmp_path, image_size=CONVERT_SIZE)
                    predicted_class, confidence = predict_image(temp_bmp_path, model)
                    print(f"File: {filename} -> Predicted: {predicted_class} ({label_map.get(predicted_class, 'Unknown')}), Confidence: {confidence:.4f}")
                    summary[predicted_class]["count"] += 1
                    summary[predicted_class]["total_confidence"] += confidence
                    summary[predicted_class]["files"].append(filename)
                    total_files += 1
                except Exception as e:
                    print(f"Error processing file {filename}: {e}")
            else:
                # 만약 BMP 등 이미지 파일이면 직접 예측 (원하는 경우)
                try:
                    predicted_class, confidence = predict_image(full_path, model)
                    print(f"File: {filename} -> Predicted: {predicted_class} ({label_map.get(predicted_class, 'Unknown')}), Confidence: {confidence:.4f}")
                    summary[predicted_class]["count"] += 1
                    summary[predicted_class]["total_confidence"] += confidence
                    summary[predicted_class]["files"].append(filename)
                    total_files += 1
                except Exception as e:
                    print(f"Error processing file {filename}: {e}")

    # 모든 파일 처리 후, 요약 결과 출력
    print("\n=== Summary ===")
    print(f"Total files processed: {total_files}")
    for cls in summary:
        count = summary[cls]["count"]
        avg_conf = summary[cls]["total_confidence"] / count if count > 0 else 0.0
        print(f"Class {cls} ({label_map.get(cls, 'Unknown')}): {count} files, Average Confidence: {avg_conf:.4f}")
        # 원하면 파일 목록도 출력할 수 있음:
        # print("Files:", summary[cls]["files"])

if __name__ == "__main__":
    main()
